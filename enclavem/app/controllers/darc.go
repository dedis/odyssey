package controllers

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/dedis/odyssey/enclavem/app/helpers"
	"github.com/dedis/odyssey/enclavem/app/models"
	"github.com/gorilla/sessions"
	"go.dedis.ch/onet/v3/log"
)

// DarcIndexHandler ...
func DarcIndexHandler(store sessions.Store, conf *models.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			darcIndexPost(w, r, store, conf)
		}
	}
}

func darcIndexPost(w http.ResponseWriter, r *http.Request,
	store sessions.Store, conf *models.Config) {
	// (!) This endpoint is publicly accessbile. In a production environment,
	// it should be protected by an authentication system, which is out of scope
	// for this project.

	// We are expecting to get a darcID
	err := r.ParseForm()
	if err != nil {
		helpers.SendRequestError(errors.New("failed to unmarshal body: "+err.Error()), w)
		return
	}

	darcID := r.PostForm.Get("darcID")
	if darcID == "" {
		helpers.SendRequestError(errors.New("did not find the 'darcID' "+
			"argument in the form"), w)
		return
	}
	log.Info("Here is the darcID from the post form: ", darcID)

	darcR, err := regexp.Compile("^darc:[0-9a-f]{64}$")
	if err != nil {
		helpers.SendRequestError(errors.New("failed to compile darc regex: "+
			err.Error()), w)
		return
	}

	ok := darcR.MatchString(darcID)
	if !ok {
		helpers.SendRequestError(fmt.Errorf("wrong darcID given in form, "+
			"regex match failed: '%s' does not match the darc regex", darcID), w)
		return
	}

	// Now let's create this darc
	desc := fmt.Sprintf("Darc generated by the enclave manager on %s",
		time.Now().Format("Mon Jan 2 15:04:05 2006"))
	cmd := exec.Command("./bcadmin", "-c", conf.ConfigPath, "darc", "add",
		"--desc", desc, "-id", conf.KeyID, "-bc", conf.BCPath, "--sign",
		conf.KeyID, "--darc", conf.DarcID, "--shortPrint", "--unrestricted")
	var outb, errb bytes.Buffer
	cmd.Stdout = &outb
	cmd.Stderr = &errb
	err = cmd.Run()
	if err != nil {
		helpers.SendRequestError(fmt.Errorf("failed to create a new DARC: %s - "+
			"Output: %s - Err: %s", err.Error(), outb.String(),
			errb.String()), w)
		return
	}

	output := outb.String()
	output = strings.Trim(output, "\n ")
	outputSplit := strings.Split(output, "\n")
	// outputSplit should contain the darcID as the first element and the
	// identity as the second
	if len(outputSplit) != 2 {
		helpers.SendRequestError(fmt.Errorf("expected the output split to "+
			"have 2 elements, but foud %d: %v", len(outputSplit), outputSplit), w)
		return
	}

	newDarcID := outputSplit[0]

	// lets check the content of the darc
	ok = darcR.MatchString(newDarcID)
	if !ok {
		helpers.SendRequestError(fmt.Errorf("regex match failed: '%s' does "+
			"not match the darc regex", newDarcID), w)
		return
	}

	// spawn:calypsoWrite
	cmd = exec.Command("./bcadmin", "-c", conf.ConfigPath, "darc", "rule",
		"--rule", "spawn:calypsoWrite", "-id", darcID, "-bc", conf.BCPath, "--sign",
		conf.KeyID, "--darc", newDarcID)
	outb.Reset()
	errb.Reset()
	cmd.Stdout = &outb
	cmd.Stderr = &errb
	time.Sleep(time.Second * 5)
	err = cmd.Run()
	if err != nil {
		helpers.SendRequestError(fmt.Errorf("failed to add rule "+
			"'spawn:calypsoWrite' on the new DARC: %s - Output: %s - Err: %s",
			err.Error(), outb.String(), errb.String()), w)
		return
	}

	// spawn:calypsoRead
	cmd = exec.Command("./bcadmin", "-c", conf.ConfigPath, "darc", "rule",
		"--rule", "spawn:calypsoRead", "-id", darcID+" | ( attr:allowed: & attr:must_have: )",
		"-bc", conf.BCPath, "--sign", conf.KeyID, "--darc", newDarcID)
	outb.Reset()
	errb.Reset()
	cmd.Stdout = &outb
	cmd.Stderr = &errb
	time.Sleep(time.Second * 5)
	err = cmd.Run()
	if err != nil {
		helpers.SendRequestError(fmt.Errorf("failed to add rule "+
			"'spawn:calypsoRead' on the new DARC: %s - Output: %s - Err: %s",
			err.Error(), outb.String(), errb.String()), w)
		return
	}

	// invoke:darc.evolve
	cmd = exec.Command("./bcadmin", "-c", conf.ConfigPath, "darc", "rule",
		"--rule", "invoke:darc.evolve", "-id", conf.KeyID+" | "+darcID,
		"-bc", conf.BCPath, "--sign", conf.KeyID, "--darc", newDarcID, "--replace")
	outb.Reset()
	errb.Reset()
	cmd.Stdout = &outb
	cmd.Stderr = &errb
	time.Sleep(time.Second * 5)
	err = cmd.Run()
	if err != nil {
		helpers.SendRequestError(fmt.Errorf("failed to add rule "+
			"'invoke:darc.evolve' on the new DARC: %s - Output: %s - Err: %s",
			err.Error(), outb.String(), errb.String()), w)
		return
	}

	resp := &models.DarcPostResponse{
		DarcID: newDarcID,
	}

	js, err := json.MarshalIndent(resp, "", "  ")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.Write(js)
}
